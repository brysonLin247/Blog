## 剪绳子

> 剑指Offer 14 - I. 剪绳子

给你一根长度为n的绳子，请把绳子剪成整数长度的m段（m、n都是整数，n > 1并且m > 1），每段绳子的长度记为k[0]，k[1]...k[m-1]。请问k[0] * k[1] * ... * k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。

示例1：

```
输入: 2
输出: 1
解释: 2 = 1 + 1, 1 × 1 = 1
```

示例2：

```
输入: 10
输出: 36
解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36
```

提示：2 <= n <= 58

## 题解

对7来说，可以拆成 3+4，最大乘积是12

对8来说，可以拆成 3+3+2，最大乘积是18

### 法一 动态规划

状态数组dp[i]表示：数字i拆分为至少两个正整数之和的最大乘积。为了方便计算，dp的长度是n+1，值初始化为1。

显然dp[2]等于1，外层循环应该从3开始遍历，一直到n停止。内存循环j从1开始遍历，一直到i之前停止，它代表数字 i 可以拆分成 j+(i-j)。但j*(i-j)不一定是最大乘积，因为i-j不一定大于dp[i-j]（数字 i - j 拆分成整数之和的最大乘积），这里要选择最大的值作为 dp[i] 的结果。空间复杂度是O($N$)，时间复杂度O($N^2$) 。代码实现如下：

```javascript
/**
 * @param {number} n
 * @return {number}
 */
var cuttingRope = function(n){
  const dp = new Array(n+1).fill(1);
  for(let i = 3;i <= n;i++){
    for(let j = 1;j < i;++j){
      dp[i] = Math.max(dp[i],j * (i - j),j * dp[i - j]);
    }
  }
  return dp[n];
}
```

### 法二 贪心法

找规律的思路，拆成多个2和3的和，保证乘积最大。因为2和3可以合成任何数字；根据贪心算法，尽量将原数拆成更多的3，然后再拆成更多的2，保证拆出来的整数的乘积结果最大。

但是有不足，如果整数n的形式是3k+1，如7时，照上面规则会被拆成“3+3+1“。应该被拆成”3+4“才对。

综上，算法的整体思路是：

- n除3的结果为a，余数是b
- 当b为0，直接将a个3相乘
- 当b为1，直接将（a-1）个3相乘，再乘以4
- 当b为2，将a个3相乘，再乘以2

空间复杂度为O(1)，时间复杂度为O(1)。代码实现如下：

```javascript
/**
 * @param {number} n
 * @return {number}
 */
var cuttingRope = function(n){
  if(n===2) return 1;
  if(n===3) return 2;
  // a的含义：n能拆成的3的个数
  const a = Math.floor(n/3);
  const b = n % 3;
  
  // n是3的倍数
  if(b===0) return Math.pow(3,a);
  // n是3k+1
  if(b===1) return Math.pow(3,a-1) * 4;
  return Math.pow(3,a) * 2;
}
```

****

坚持每日一练！前端小萌新一枚，希望能点个`赞`+`在看`哇～

